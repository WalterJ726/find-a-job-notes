

## 计算机网络

#### Keep alive

TCP和HTTP中的Keep-Alive字段都是用来优化网络性能的。下面分别介绍一下它们的作用：

1. TCP中的Keep-Alive

TCP协议是面向连接的，建立连接需要经过三次握手，断开连接需要经过四次握手。如果在一个HTTP事务中需要多次请求，则每次都需要建立和断开TCP连接，这样会带来额外的开销和延迟。

TCP协议中的Keep-Alive机制可以在两次请求之间保持TCP连接的状态，避免了建立和断开连接的开销，减少了延迟和资源的消耗。当客户端和服务器之间的一次TCP连接中完成了一个HTTP事务，但TCP连接仍然保持打开状态，可以被重复利用，这种保持连接的机制就是TCP Keep-Alive。

在TCP Keep-Alive机制中，客户端向服务器发送一个Keep-Alive消息，服务器收到后会返回一个相应的消息，以此保持连接的状态。如果一定时间内没有数据传输，则连接会被自动关闭。这个时间间隔可以通过修改TCP的Keep-Alive定时器的值来调整。

1. HTTP中的Keep-Alive

在HTTP/1.0中，每个请求都需要重新建立TCP连接，这样会增加很多额外的开销和延迟。为了解决这个问题，HTTP/1.1引入了Keep-Alive机制，可以在一个TCP连接上进行多次请求和响应，避免了建立和断开连接的开销。

在HTTP/1.1中，默认情况下是开启Keep-Alive的，如果服务器不想保持连接，则需要在响应头中指定Connection: close字段来关闭Keep-Alive。

HTTP中的Keep-Alive机制可以减少网络传输的开销，提高网络性能，但也需要注意保持连接时间过长会占用服务器资源。因此，在实际应用中需要根据具体的场景来调整Keep-Alive的参数。

TCP中的Keep-Alive机制是通过发送心跳包来判断连接是否断开，从而保持TCP连接的状态。当一端长时间未收到另一端的数据时，就会发送心跳包，如果连续发送几次都没有收到回复，则认为连接已经断开。

#### 状态码

1xx（信息性状态码）：请求已被服务器接收，继续处理中。

- 100（继续）：服务器收到请求，需要客户端继续发送请求的其余部分。

2xx（成功状态码）：请求已成功处理完毕。

- 200（成功）：请求已成功处理。

3xx（重定向状态码）：需要客户端采取进一步的操作才能完成请求。

- 301（永久重定向）：请求的资源已经被永久移动到新 URI，返回信息中包含新的 URI。
- 302（临时重定向）：请求的资源已经被临时移动到新 URI，返回信息中包含新的 URI。

4xx（客户端错误状态码）：客户端的请求有错误，常见的有“未授权”、“禁止访问”、“请求不存在”等。

- 400（错误请求）：请求中存在语法错误或无法满足请求。
- 401（未授权）：请求需要身份验证。
- 403（禁止访问）：服务器拒绝请求。
- 404（未找到）：请求的资源不存在。

5xx（服务器错误状态码）：服务器未能完成请求，常见的有“服务器内部错误”、“服务器过载”等。

- 500（服务器内部错误）：服务器遇到了一个未曾预料的状况，导致无法完成客户端的请求。
- 502（错误网关）：服务器作为网关或代理，从上游服务器接收到了一个无效的响应。
- 503（服务不可用）：服务器暂时处于过载或维护状态

#### HTTP

HTTP（HyperText Transfer Protocol）是一种用于传输超文本的协议，是 Web 浏览器和 Web 服务器之间通信的基础。HTTP是一个无状态协议，即每个请求都是相互独立的，服务器不会保存任何客户端请求的信息。HTTP基于请求/响应模型，客户端发送请求给服务器，服务器返回响应。

HTTP协议的请求和响应消息都包含三个部分：起始行、首部和主体。起始行包含请求方法或响应状态码、URI和HTTP版本号；首部包含一些附加信息，如Cookies、请求的MIME类型、响应的Content-Type等；主体包含实际的数据内容，如网页的HTML文档。

此外，HTTP还有一些相关的协议和标准，如

HTTPS（HTTP over SSL/TLS），REST（Representational State Transfer，一种基于HTTP协议的软件架构风格）

#### HTTP1.0和1.1

1. 持久连接

HTTP 1.0中，默认情况下每个请求/响应都需要建立新的连接。这会导致性能问题，因为在每个请求/响应之间建立连接会浪费时间和资源。在HTTP 1.1中，使用持久连接可以在单个连接上发送多个请求/响应，从而减少了网络延迟和服务器负担。

2. 分块传输编码

在HTTP 1.0中，服务器无法将响应拆分为多个部分进行传输。这意味着客户端必须等待服务器完成整个响应才能开始处理它。在HTTP 1.1中，使用分块传输编码可以在传输期间将响应拆分为多个部分。这意味着客户端可以更早地开始处理响应，从而提高了性能。

3. **请求管线化**

在HTTP 1.0中，请求管线化不是强制要求的。这意味着客户端只能在接收到前一个请求的响应后才能发送下一个请求。在HTTP 1.1中，请求管线化是默认启用的。这意味着客户端可以同时发送多个请求，而无需等待前一个请求的响应。

4. 缓存处理

在HTTP 1.0中，缓存处理不是强制要求的。这意味着服务器无法告诉客户端如何缓存响应。在HTTP 1.1中，服务器可以使用Cache-Control响应头来告诉客户端如何缓存响应。这可以减少对服务器的请求，从而提高性能。

```txt
public：响应可以被任何对象（包括客户端和代理服务器）缓存。

private：响应只能被单个用户缓存，不能被共享缓存（例如代理服务器）缓存。

no-cache：客户端和缓存服务器不能缓存响应，每次都必须重新获取响应。

no-store：客户端和缓存服务器不能缓存响应，并且不允许将响应保存在任何持久化存储中（例如硬盘）。no-cache和no-store指令之间的主要区别在于，no-cache指令仍然允许缓存，但缓存服务器必须在每次请求时重新验证响应的有效性，而no-store指令完全禁止任何形式的缓存。

must-revalidate：客户端和缓存服务器必须在使用缓存响应之前验证响应的有效性。如果响应过期或被修改，则必须从服务器获取新的响应。

max-age：指定响应在被缓存之前可以被保持的时间长度（以秒为单位）。

s-maxage：类似于max-age，但只适用于共享缓存（例如代理服务器），而不适用于客户端缓存。

no-transform：禁止代理服务器修改响应的媒体类型或编码。

immutable：响应内容是不可变的，即使缓存已过期，也不能从源服务器重新获取新的响应。
```

5. Host头部

在HTTP 1.0中，每个请求都需要使用完整的URL来标识服务器上的资源。在HTTP 1.1中，使用Host头部可以在单个IP地址上托管多个域名。这使得共享主机变得更加容易。

#### http和https的区别？

HTTP（HyperText Transfer Protocol）是一种用于传输超文本的协议，它是基于**TCP/IP协议**的应用层协议。它的主要特点是简单、快速，但是传输的数据是明文的，容易被窃听、篡改和劫持。因此，HTTP通常不适用于对数据安全性要求较高的场景，如网上银行、电子商务等。

HTTPS（HyperText Transfer Protocol Secure）是基于HTTP协议，**通过SSL或TLS加密协议来保证数据**的安全传输。HTTPS的加密方式采用**公钥加密和私钥解密**的方式，使用SSL证书来验证服务器的身份，可以保证传输的数据不被篡改、窃取或者伪造。因此，HTTPS适用于对数据安全性要求较高的场景，如网上银行、电子商务等。

数据加密、身份认证、数据完整性（integrity）

**具体来说，HTTP和HTTPS的区别有以下几个方面：**

1. **安全性：HTTPS比HTTP更安全，能够防止数据被窃听、篡改和伪造。**
2. **加密方式：HTTPS使用SSL或TLS加密协议，HTTP没有加密。**
3. **端口号：HTTP默认端口号是80，HTTPS默认端口号是443。**
4. **速度：由于HTTPS需要进行加密和解密操作，因此比HTTP的传输速度慢一些。**

总之，如果涉及到敏感信息的传输，比如用户名、密码等，应该使用HTTPS协议来保证数据的安全性。

#### HTTPS具体实现

HTTPS的加密过程主要包括以下几个步骤：

1. 客户端发送请求：客户端向服务器发送HTTPS请求。
2. 服务器响应：服务器返回数字证书。
3. 客户端验证证书：客户端验证服务器的数字证书是否合法，包括证书的颁发机构、证书的有效期等等。
4. 生成对称密钥：客户端使用服务器的公钥加密随机生成的对称密钥，并将加密后的密钥发送给服务器。
5. 传输加密：客户端和服务器使用协商好的对称密钥进行数据加密和解密。
6. 完成握手：握手成功后，客户端和服务器开始进行加密通信。

在以上过程中，数字证书起到了关键的作用，数字证书用于证明服务器的身份和加密数据的公钥。数字证书由数字证书颁发机构（CA）颁发，包含服务器的公钥、服务器的名称、颁发机构的名称等信息。在HTTPS握手过程中，客户端会验证服务器返回的数字证书是否有效，如果数字证书有效，则客户端会生成随机的对称密钥并使用服务器的公钥加密发送给服务器，确保数据的安全性。

总之，HTTPS通过使用TLS/SSL协议对HTTP数据进行加密、身份认证和数据完整性保护，确保数据在传输过程中的安全性和保密性。数字证书则用于验证服务器的身份和加密数据的公钥，保证通信双方的真实身份。

#### OSI七层模型？TCP/IP四层模型？五层协议？

物理层，链路层，网络层，传输层，会话层，表示层，应用层

1. TCP/IP四层模型

- 应用层（Application Layer）
- 传输层（Transport Layer）
- 网络层（Network Layer）
- 链路层（Link Layer）

五层协议

- 应用层（Application Layer）（表示层，会话层）
- 传输层（Transport Layer）
- 网络层（Network Layer）
- 数据链路层（Data Link Layer）分为数据链路层和物理层两层
- 物理层（Physical Layer）

#### TCP如何提供可靠数据传输的？ 

建⽴连接（标志位）：通信前确认通信实体存在。 

序号机制（序号、确认号）：确保了数据是按序、完整到达。

数据校验（校验和）：CRC校验全部数据。 

超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。 

窗⼝机制（窗⼝）：提供流量控制，避免过量发送。 

拥塞控制：同上。

#### 如何区分流量控制和拥塞控制？

 流量控制属于通信双⽅协商；拥塞控制涉及通信链路全局。 流ᰁ控制需要通信双⽅各维护⼀个发送窗、⼀个接收窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由 接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化由试探性发送⼀定数据ᰁ数据探查⽹络 状况后⽽⾃适应调整。 实际最终发送窗⼝ = min{流控发送窗⼝，拥塞窗⼝}。

TCP 主要通过四个算法来进行拥塞控制：

**慢开始、拥塞避免、快重传、快恢复。**

#### tcp和udp有什么区别，应用场景

可以共存，端口是不一样的

TCP（传输控制协议）和UDP（用户数据报协议）是两种不同的网络传输协议，它们有以下几个区别和应用场景：

1. 连接性：TCP 是面向连接的协议，UDP 是无连接的协议。TCP 通过三次握手建立连接，传输数据之前必须要建立连接，而 UDP 不需要建立连接就可以直接传输数据。
2. 可靠性：TCP 提供可靠的数据传输服务，确保数据不会丢失和损坏。TCP 的可靠性是通过数据包确认机制、超时重传机制和流量控制来保证的。而 UDP 没有提供可靠性保证，它只是尽可能快地传输数据，并且不保证数据包的顺序和完整性。
3. 传输速度：UDP 比 TCP 更快，因为它没有 TCP 那样的握手和确认机制，并且没有流量控制，因此它可以尽可能快地传输数据。但是，由于 UDP 不提供可靠性保证，因此数据的传输过程中可能会丢失或损坏。
4. 应用场景：TCP 适合于对可靠性和有序性要求较高的应用，例如 HTTP、FTP 等应用；而 UDP 适合于对传输速度和实时性要求较高的应用，例如视频流、语音通话等应用。

#### TCP和udp有那些应用层协议

常见的基于 TCP 协议的应用层协议有：

1. HTTP：超文本传输协议，用于 Web 应用程序之间的数据传输。
2. FTP：文件传输协议，用于文件传输和管理。
3. SMTP：简单邮件传输协议，用于电子邮件的传输。
4. Telnet：远程终端协议，用于远程控制计算机或网络设备。
5. SSH：安全外壳协议，用于安全地远程访问计算机或网络设备。

常见的基于 UDP 协议的应用层协议有：

1. DNS：域名系统，用于将域名解析为 IP 地址。
2. DHCP：动态主机配置协议，用于自动配置 IP 地址、子网掩码等网络参数。
3. TFTP：简单文件传输协议，用于在网络上进行简单的文件传输。
4. SNMP：简单网络管理协议，用于远程管理网络设备。

#### TCP三次握手四次挥手

- 第⼀次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -> SYN_SEND） 
- 第⼆次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -> SYN_RECV）
- 第三次：客户机发送含ACK位，**ACK_NUM = P + 1**的包到服务器。（客 -> ESTABLISH，服 -> ESTABLISH）第三次可以携带数据

接下来，以三个方面分析三次握手的原因：

- 三次握手才可以阻止重复历史连接的初始化（主要原因）

- 三次握手才可以同步双方的初始序列号

  四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

  而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

- 三次握手才可以避免资源浪费

  如果只有「两次握手」，当客户端发生的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端每收到一个 `SYN` 就只能先主动建立一个连接**，这会造成什么情况呢？

  如果客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

  我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认报文，所以每收到一个 `SYN` 就只能先主动建立一个连接」这个场景。

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



#### 建立的时候握手断开了怎么办

##### 第一次握手丢失了，会发生什么？

当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。

##### 第二次握手丢了

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

##### 第三次握手丢失

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

#### 四次挥手

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

在挥手过程中，每个节点必须维护一个定时器，如果在一段时间内没有收到对方的回复，则重新发送报文。为了保证挥手的正确性，TCP协议规定，收到FIN报文后，需要等待2倍的最大报文段生存时间（MSL）才能关闭连接。

MSL是指TCP报文在网络中的最长生存时间，它的值通常为2分钟。MSL的目的是确保网络中所有的数据包都能够被完全接收或丢弃，避免数据包在网络中无限期地循环，导致网络拥堵或其他问题。

因此，挥手中需要等待2倍的MSL的时间，是为了确保网络中的所有数据包都能够被完全接收或丢弃，避免数据包在网络中无限期地循环。这样可以保证连接的可靠关闭。

- TIME_WAIT 是主动关闭链接时形成的，等待`2MSL`时间，约 44 分钟。主要是防止最后一个`ACK`丢失。 由于`TIME_WAIT` 的时间会非常长，因此server端应尽量减少主动关闭连接
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对⽅的FIN包之后， ⾃然是需要⽴即回复ACK包的，表示已经知道断开请求。但是本⽅是否⽴即断开连接（发送FIN包）取决 于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。因为不知道服务器还有没有数据要发送
- FIN_WAIT_2： 半关闭状态。 发送断开请求⼀⽅还有接收数据能⼒，但已经没有发送数据能⼒。

time_wait 是表示主动关闭连接的一方等待一段时间后，确认对方收到关闭连接请求并完成了关闭，而 close_wait 是表示等待本地应用程序关闭连接的状态。因此，当一个应用程序没有正确关闭连接时，就会出现大量的 close_wait 状态的 socket，导致系统资源的浪费和性能下降

#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

主要原因有两个方面：

- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

#### 从浏览器中输入网址到显示页面的全过程？

```
 【浏览器地址栏输⼊URL回⻋后涉及到的流程】  

1.0 浏览器解析URL，将其分解成协议、主机名、端口号（如果有）、路径和查询字符串等各个部分。

1.1 查找DNS缓存 
    1. 先查找浏览器DNS缓存，看是否存放⽬标⽹络的IP地址;  
    2. 如果不在浏览器缓存，则浏览器将对操纵系统发起系统调⽤，查询操作系统本地缓存;  
    3. 如果不在操作系统本地缓存，则浏览器会查询与之相连的路由器缓存;  
    4.  如果不在路由器缓存，则浏览器会检查ISP【本地通信服务商】缓存; 
    5.  若以上四步均没有查询到⽬标⽹络的IP地址，则发起DNS查询。 

1.2 发起DNS查询 
	判断DNS服务器和我们的主机是否在同⼀⼦⽹内 
	1. 在同⼀⼦⽹，则采⽤ ARP 地址解析协议对 DNS 服务器进⾏ ARP 查询  
	2. 不在同⼀⼦⽹，则采⽤ ARP 地址解析协议对默认⽹关进⾏查询 
	若此时还是查询不到 IP 地址，则根据拿到 DNS 服务器或者默认⽹关的 IP 地址，继续进⾏ DNS 请求 
	使⽤53端⼝先向本地 DNS 服务器发送 UDP 请求包，此处⼀般使⽤ UDP 协议（如果响应包太⼤，则使⽤ TCP 协 议）  
	没有查询到 IP 地址： 则它会发送⼀个递归查询请求，⼀层⼀层向⾼层DNS服务器查询，直到查询到 IP 地址，则将结果返回 【解释：DNS 是分布式域名服务器，每台服务器只维护⼀部分 IP 地址到⽹络地址的映射，没有任何⼀台服务器能 够维持全部的映射关系】。  

1.3 封装TCP数据包 
	拿到 IP 地址后，根据 URL 中的端⼝可知端⼝号【HTTP：80；HTTPS：443】，⼀般先会先尝试建⽴ HTTP 连接;  准备 TCP 数据包：  
	步骤：  
	1. 将应⽤层传递下来的实际数据，在传输层添加TCP⾸部;  
	2. 将传输层传下来的数据在⽹络层添加IP⾸部;  
	3. 将⽹络层传输下来的数据，在数据链路层添加以太⽹⾸部，并在传输介质中进⾏传输。  
	
1.4 浏览器与⽬标服务器建⽴TCP连接 
	经过上述DNS和ARP查询流程后，浏览器会收到⽬标服务器的IP和MAC地址，然后经过三次握⼿后建⽴TCP连接; 
	1、使⽤HTTP协议  
	浏览器发送请求到服务器，如果使⽤的是HTTP协议，则服务器直接返回结果;  
	2、使⽤HTTPS协议  如果不是 HTTP 协议，则服务器会返回⼀个以 3 开头的᯿定向消息，告诉浏览器使⽤的 HTTPS，IP 没变，只是端⼝号变成 443；
	完成四次挥⼿；
	新建⽴ TCP 连接，将端⼝号修改为 443，同时沟通好双⽅的使⽤的认证算法、加密和解密算法，在次过程中也会 检查对⽅的 CA 安全证书，采⽤ SSL 加密技术进⾏传输数据。  

1.5 浏览器发送HTTP/HTTPS请求到web服务器 主要使⽤两种请求⽅式： 
	1. 浏览器发送get请求，要求⽬标服务器提供输⼊的⽹⻚;  
	2. 浏览器发送post请求，表示填写的是表单。  
	
1.6 服务器处理请求并发挥⼀个响应 
	服务器会从浏览器接受请求并将其传递给请求处理程序并响应;  
	
1.7 服务器发回⼀个HTTP响应
	⼀般响应包包含：请求的⽹⻚以及状态码，压缩类型，如何缓存的⻚⾯，设置的cookie;  
	
1.8 浏览器显示HTML⻚⾯ 
	1. 渲染HTML⻣架；涉及到Ajax技术;  
	2. 检查HTML标记并发送GET请求以获取⽹⻚上的其他元素【图像、CSS样式、JS⽂件等】，该静态⽂件⼀般由 浏览器缓存，再次访问，不⽤᯿新请求;  
	3. 最后会看到请求⾊彩斑斓的⽹⻚。 
```

#### cookie和session的区别

1. 存储位置不同

Cookie数据存储在客户端（即用户的浏览器）中，而Session数据存储在服务器端。具体来说，服务器会在内存或磁盘中创建一个Session对象，用于存储用户的会话信息。

1. 安全性不同

由于Cookie存储在客户端中，因此容易受到跨站点脚本攻击（XSS）和跨站点请求伪造攻击（CSRF）等安全威胁。为了保护Cookie的安全性，可以通过对Cookie设置HttpOnly、Secure等属性来防止这些攻击。而Session存储在服务器端，因此相对来说更加安全。

1. 数据量不同

Cookie可以存储的数据量有限，通常不超过4KB。而Session可以存储更大的数据量，因为它是存储在服务器端的。

1. 生命周期不同

Cookie有一个过期时间，在过期时间之前一直有效。而Session的生命周期取决于用户的活动情况，当用户关闭浏览器或长时间不活动时，Session会自动过期并被销毁。

1. 实现方式不同

Cookie是在服务器端通过**响应头中的Set-Cookie字段来设置的**，而客户端会将Cookie存储在浏览器中。而Session是通过在服务器端创建一个Session对象来实现的，客户端只是通过Session ID来标识不同的Session。

由于 Http 是一种无状态的协议，为了识别连接的发起者是谁，需要应用层自己去实现，因此诞生了 Session 和 cookie。Session 是保存在服务器端，Cookie 保存在客户端。





# 题目面经



Https，对称加密和非对称加密，为什么要这样做，为什么用对称加密