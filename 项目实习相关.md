## 项目

### tinySTL

**预处理指令** #pragma once 防止头文件重复引用



一字节对齐

### webserver

http1.1和1.0有什么区别

cache control字段

##### bind绑定端口

在服务端，如果不调用 bind 函数绑定一个端口号，那么内核会自动为该服务分配一个随机的端口号。这样，客户端就无法事先知道服务端的端口号，需要在连接时动态获取。如果服务端需要暴露给外部的端口号不确定或需要保持一致，那么就需要显式地调用 bind 函数指定端口号。

在客户端，通常不需要显式地调用 bind 函数绑定端口号。如果调用 bind 函数指定一个端口号，那么客户端就会使用该端口号进行通信，这可能会影响到客户端与服务端的通信效率。因此，在客户端一般不需要显式地调用 bind 函数。



服务器

创建socket -> int socket(int domain, int type, int protocol)

绑定socket和端⼝号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)

监听端⼝号 -> int listen(int sockfd, int backlog)

接收⽤户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)

从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count)

关闭socket -> int close(int fd)

客户端

创建socket -> int socket(int domain, int type, int protocol);

连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);

向socket写⼊信息 -> ssize_t write(int fd, const void *buf, size_t count);

关闭oscket -> int close(int fd);

#### proactor模式

Proactor 模式是一种高效的异步 I/O 模型，它属于 Reactor 模式的变种。在 Proactor 模式中，当一个 I/O 操作完成后，操作的结果会被封装成一个事件，然后通过操作系统的异步通知机制通知应用程序。应用程序通过事件处理器处理这个事件，从而完成 I/O 操作。

Proactor 模式相对于 Reactor 模式的优势在于，在 I/O 操作执行期间，操作系统会负责将数据从内核空间复制到用户空间，从而减少了用户空间和内核空间之间的数据拷贝操作，提高了 I/O 操作的效率。同时，Proactor 模式也能够充分利用操作系统的异步通知机制，减少了用户空间和内核空间之间的切换次数，提高了应用程序的并发处理能力。

在 Proactor 模式中，应用程序需要将 I/O 操作的完成事件与相应的处理器关联起来，这个关联关系可以通过事件处理器的注册来实现。当 I/O 操作完成后，操作系统会通知应用程序相关的事件处理器，然后应用程序就可以在事件处理器中获取到 I/O 操作的结果，并进行相应的处理。

Proactor 模式适用于高并发、高吞吐量的应用程序场景，例如网络服务器、数据库系统等。常见的 Proactor 实现包括 Windows 的 I/O Completion Port 和 Linux 的 AIO (Asynchronous I/O) 等。

#### websocket和socket

1. Socket Socket是一种面向流的网络通信协议，主要用于实现客户端和服务端之间的数据传输。它基于传输控制协议TCP或用户数据报协议UDP，能够实现可靠的数据传输，但需要应用程序自己实现消息分包、粘包等处理。Socket通信一般需要编写底层网络通信代码，实现细节较多，使用起来较为复杂。
2. WebSocket WebSocket是一种全双工的网络通信协议，基于HTTP协议，通过在HTTP握手阶段升级协议，从而实现长连接。WebSocket能够实现服务器主动向客户端推送数据，而不需要客户端发送请求，从而节省网络带宽和服务器资源。同时，WebSocket协议支持二进制和文本数据传输，能够实现更加灵活和高效的数据交互。WebSocket通信相对于Socket通信来说，使用起来更加简单，但需要服务端和客户端都支持WebSocket协议。
3. `websocket` 用的是 `TCP` 还是`UDP`

> WebSocket是基于TCP协议的

#### thrift的接口

1. Synchronous接口 Synchronous接口是最基本的接口类型，它是一种阻塞式调用方式，即客户端发起请求后需要等待服务端响应返回结果。这种接口适用于对服务响应速度不敏感的场景。
2. Asynchronous接口 Asynchronous接口是一种非阻塞式调用方式，即客户端发起请求后可以继续执行其他任务，服务端响应返回结果后再通知客户端。这种接口适用于对服务响应速度较为敏感的场景。
3. One-way接口 One-way接口是一种单向调用方式，即客户端发送请求后不需要等待服务端响应，而是直接继续执行后续任务。这种接口适用于对响应结果不关心的场景，例如日志记录等。
4. Callback接口 Callback接口是一种回调式调用方式，即客户端发送请求后服务端将结果通过回调函数的方式通知客户端。这种接口适用于对服务端主动推送结果的场景，例如消息推送等。

#### 设计的游戏引擎

动态刷新，

粒子效果：往外散射，每一个角度都往外散射粒子

碰撞：两个球碰到了之后都会往后弹，然后会减速

随机发射炮弹

#### Oauth2

OAuth 2.0是一种授权框架，用于在不泄露用户凭据的情况下授权第三方应用程序访问受保护的资源。它允许用户在不与第三方共享他们的用户名和密码的情况下，授权第三方应用程序访问他们的受保护资源。OAuth 2.0由一组角色、授权流和令牌组成，包括以下几个组成部分：

1. 授权服务器(Authorization Server)：验证并授权第三方应用程序的请求，然后向应用程序发放访问令牌(Access Token)。
2. 资源服务器(Resource Server)：存储受保护的资源，并且仅当受到有效令牌的请求时才提供对资源的访问。
3. 第三方应用程序(Client)：向授权服务器请求访问令牌，并使用该令牌向资源服务器请求受保护资源。
4. 资源拥有者(Resource Owner)：拥有访问受保护资源的用户，可以授权第三方应用程序访问他们的资源。

OAuth 2.0定义了四种授权流程：

1. 授权码模式(Authorization Code Grant)：适用于Web应用程序和移动应用程序，它允许第三方应用程序通过重定向用户的浏览器来获取授权码(Authorization Code)，然后使用该授权码向授权服务器请求访问令牌。
2. 简化模式(Implicit Grant)：适用于Web应用程序和移动应用程序，它允许第三方应用程序在不涉及授权码的情况下向授权服务器请求访问令牌。
3. 密码模式(Resource Owner Password Credentials Grant)：适用于受信任的第一方应用程序，它允许第三方应用程序使用资源拥有者的用户名和密码来请求访问令牌。
4. 客户端凭证模式(Client Credentials Grant)：适用于机器到机器通信的场景，它允许第三方应用程序使用客户端ID和客户端秘钥来请求访问令牌。

OAuth 2.0提供了一个灵活而安全的机制，允许用户授权第三方应用程序访问他们的资源，同时不需要共享他们的凭据。它是一种非常流行的授权框架，广泛应用于Web应用程序和移动应用程序的开发中。



#### 你来设计一个网络库，你会怎么设计？（不知道，遵循Ractor模型？）

设计一个网络库需要考虑多个方面，包括接口设计、协议支持、网络通信、多线程处理、错误处理等。下面是一个简单的网络库设计方案，供参考：

1. 接口设计
   - 应该提供简单易用的接口，包括创建和销毁网络连接、发送和接收数据等操作。
   - 应该支持同步和异步操作两种模式，并提供相应的回调函数。
   - 应该支持不同的协议，例如 TCP、UDP、HTTP 等。
   - 应该提供网络事件通知机制，例如连接建立和关闭、数据接收和发送等事件。
2. 协议支持
   - 应该支持常见的协议，例如 TCP、UDP、HTTP、WebSocket 等。
   - 应该提供相应的协议解析器，能够解析协议头和数据，并提供相应的回调函数。
   - 应该支持自定义协议，能够灵活适应不同的应用场景。
3. 网络通信
   - 应该使用非阻塞 IO 模型，能够处理大量并发连接。
   - 应该使用 IO 多路复用技术，例如 select、poll、epoll 等，提高网络通信效率。
   - 应该支持数据加密和压缩等功能，提高数据传输安全性和效率。
4. 多线程处理
   - 应该使用线程池技术，避免频繁地创建和销毁线程。
   - 应该使用任务队列，将网络事件和数据处理任务提交到任务队列中，由线程池处理。
5. 错误处理
   - 应该提供错误处理机制，能够捕获和处理网络异常和错误。
   - 应该提供日志记录功能，便于调试和排查错误。

以上是一个简单的网络库设计方案，实际设计中需要根据具体应用场景进行调整和优化。同时，在设计网络库时还需要考虑网络安全、性能优化、代码可读性等方面的问题。



7 还问了我为什么不用cookie，没答上来，我只能回答一下cookie 和 session的区别

8 项目中中间件是怎么用的，回答就是用Django自带的MiddlewareMixin类做的，感觉还要再了解一下中间件

9 简单介绍一下Django框架，回答是MVC和ORM



我回答登录模块的实现（session 中间件 验证码）