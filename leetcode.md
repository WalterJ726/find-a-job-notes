## 算法题

 循环有序数组

讲一讲快速排序(口头讲述) 是否是稳定的 为什么

手撕 ： 循环有序数组

**先序遍历 中序遍历得到后续遍历**

  8、算法：最长公共子串，不是最长公共子序列，但是想法类似，一开始暴力，然后用DP优化。



## 智力题

64匹马，8个赛道，决出前四，最少比赛几次？

概率题：一个骰子，怎么等概率地从9个人中选出两个人。  

  方案一：一个一个选，可以，但是面试官想要更好的  

  方案二：一次选出两个，get到面试官的点了  

组合的想法，九个人抽两个，一共有36种配对方案，投两次骰子也有36种可能 

**问了一个 有n个桶 现在每个桶中有不用数量的东西 问调整次数最少让桶中数量等于平均数量**





## 算法题

程序题：（面试官没调好，没做成）

后序遍历

leetcode151反转字符串单词的升级版，会有不是字母的情况。没写出来，但是思路还是有点，15分钟太少了，整理一下思路就基本没啥时间了，太菜了，而且也忘了字符转ASCII码的那个函数是啥了（ord/chr），寄

#### 排序

堆排序（Heap Sort）：

- 时间复杂度：O(nlogn+n) 建堆
- 空间复杂度：O(1)

快速排序（Quick Sort）：

- 时间复杂度：O(nlogn)（期望情况），O(n^2)（最坏情况）
- 空间复杂度：O(logn)

归并排序（Merge Sort）：

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

快排，找pivot，然后根据大小，交换元素

1. 冒泡排序（Bubble Sort）、插入排序（Insertion Sort）、归并排序（Merge Sort）、计数排序（Counting Sort）和基数排序（Radix Sort）是稳定的排序算法。
2. 快速排序（Quick Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）和堆排序（Heap Sort）是不稳定的排序算法。

##### 查找次数

假设顺序表中有 n 个元素，查找成功的平均长度指的是平均需要比较多少个元素才能找到目标元素。

如果顺序表中的元素是随机排列的，那么查找成功的平均长度为 (n+1)/2，即顺序表长度的一半再加一。这是因为，在随机情况下，每个元素被查找到的概率相等，因此平均需要比较的元素个数是所有元素位置的平均值，即：

(1+2+...+n)/n = (n+1)/2



 判断链表是否是回文链表 

 判断二叉树是否是二叉搜索树 